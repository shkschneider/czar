.PHONY: all build clean test install

# Compiler paths
CC = cc
LUAJIT = luajit
AR = ar
CFLAGS = -I/usr/include/luajit-2.1
LDFLAGS = -L. -Wl,--whole-archive -lczar -Wl,--no-whole-archive -Wl,-E -lluajit-5.1 -lm -ldl

# Lua source files
LUA_SOURCES = lexer.lua parser.lua codegen.lua cz
LUA_OBJECTS = lexer.o parser.o codegen.o cz.o
LUA_LIBRARY = libczar.a

# Find all test .cz files
TEST_FILES = $(wildcard tests/*.cz)
EXPECTED_RESULTS = \
	types:42 \
	bindings:30 \
	structs:15 \
	pointers:30 \
	functions:19 \
	arithmetic:53 \
	comparison:1 \
	if_else:50 \
	while:55 \
	comments:60 \
	no_semicolons:15

# Build the cz binary from Lua bytecode
build: cz.bin
	@echo "Build complete: cz.bin"

# Compile Lua files to object files and create static library
$(LUA_LIBRARY): $(LUA_OBJECTS)
	$(AR) rcus $@ $^

# Compile individual Lua files to bytecode object files
lexer.o: lexer.lua
	$(LUAJIT) -b $< $@

parser.o: parser.lua
	$(LUAJIT) -b $< $@

codegen.o: codegen.lua
	$(LUAJIT) -b $< $@

cz.o: cz
	$(LUAJIT) -b $< $@

# Generate sizes file from object files
bytecode_sizes.c: $(LUA_OBJECTS)
	@echo "// Auto-generated bytecode sizes" > $@
	@echo "#include <stddef.h>" >> $@
	@for obj in $(LUA_OBJECTS); do \
		name=$$(basename $$obj .o); \
		size=$$(nm -S $$obj | grep luaJIT_BC | awk '{print "0x" $$2}'); \
		echo "const size_t luaJIT_BC_$${name}_size = $$size;" >> $@; \
	done

# Link the C main file with the Lua library to create the binary
cz.bin: cz_main.c bytecode_sizes.c $(LUA_LIBRARY)
	$(CC) $(CFLAGS) -o $@ cz_main.c bytecode_sizes.c $(LDFLAGS)

# Default target: build and run tests
all: build test

# Run the test suite
test: build
	@echo "Running all tests..."
	@passed=0; failed=0; \
	for test in $(TEST_FILES); do \
		name=$$(basename $$test .cz); \
		echo "Testing $$name..."; \
		./cz.bin $$test -o tests/$$name > /dev/null 2>&1; \
		compile_status=$$?; \
		if [ $$compile_status -ne 0 ] || [ ! -f tests/$$name ]; then \
			echo "  FAIL: Compilation failed"; \
			failed=$$((failed + 1)); \
			continue; \
		fi; \
		tests/$$name; \
		exit_code=$$?; \
		expected=$$(echo "$(EXPECTED_RESULTS)" | tr ' ' '\n' | grep "^$$name:" | cut -d: -f2); \
		if [ -n "$$expected" ]; then \
			if [ $$exit_code -eq $$expected ]; then \
				echo "  PASS (exit code: $$exit_code)"; \
				passed=$$((passed + 1)); \
			else \
				echo "  FAIL: Expected exit code $$expected, got $$exit_code"; \
				failed=$$((failed + 1)); \
			fi; \
		else \
			echo "  PASS (exit code: $$exit_code, no expected value)"; \
			passed=$$((passed + 1)); \
		fi; \
	done; \
	echo ""; \
	echo "Results: $$passed passed, $$failed failed"; \
	if [ $$failed -gt 0 ]; then exit 1; fi

# Clean build artifacts
clean:
	rm -f ./example.c ./a.out ./my_program
	rm -f *.o *.a cz.bin $(LUA_LIBRARY) bytecode_sizes.c
	rm -f tests/*.c tests/test_types tests/test_bindings tests/test_structs tests/test_pointers \
		tests/test_functions tests/test_arithmetic tests/test_comparison tests/test_if_else \
		tests/test_while tests/test_comments tests/test_no_semicolons

# Install the cz compiler (requires root/sudo for system-wide install)
install: build
	@echo "Installing cz.bin to /usr/local/bin/cz"
	@echo "You may need to run this with sudo"
	install -m 755 cz.bin /usr/local/bin/cz
	@echo "Installation complete. You can now use 'cz' from anywhere."
