// Demo: Constructor and Destructor Example
// Demonstrates automatic initialization and cleanup with Type:new() and Type:free()

struct FileHandle {
    i32 fd
    bool is_open
}

// Constructor: automatically called when creating a FileHandle
fn FileHandle:new() -> void {
    self.fd = 0
    self.is_open = false
}

// Destructor: automatically called when freeing a FileHandle
fn FileHandle:free() -> void {
    // In a real program, this would close the file descriptor
    self.is_open = false
}

fn FileHandle:open(i32 file_descriptor) -> void {
    self.fd = file_descriptor
    self.is_open = true
}

fn FileHandle:close() -> void {
    self.fd = 0
    self.is_open = false
}

struct Database {
    i32 connection_count
    bool is_connected
}

// Constructor for Database
fn Database:new() -> void {
    self.connection_count = 0
    self.is_connected = false
}

// Destructor for Database
fn Database:free() -> void {
    // Cleanup: disconnect
    self.is_connected = false
    self.connection_count = 0
}

fn Database:connect() -> void {
    self.is_connected = true
    self.connection_count = 1
}

fn main() -> i32 {
    // Example 1: Stack allocation with automatic constructor
    FileHandle file = FileHandle {}
    // Constructor automatically called, fd=0, is_open=false
    
    // Example 2: Heap allocation with automatic constructor and cleanup
    mut Database db = new Database {}
    // Constructor automatically called, connection_count=0, is_connected=false
    
    db:connect()
    // Now: connection_count=1, is_connected=true
    
    // Explicit cleanup
    free db
    // Destructor automatically called before free()
    
    // Example 3: Heap allocation with automatic scope-based cleanup
    FileHandle file2 = new FileHandle {}
    file2:open(42)
    // file2 will be automatically freed at scope exit
    // Destructor will be called, then memory freed
    
    return 0
}
