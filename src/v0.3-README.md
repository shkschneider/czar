# CZar v0.3 - Core Runtime

This release introduces the core CZar runtime header `cz.h` which provides:

## Type Aliases

Fixed-width integer types with `cz_` prefix:

```c
cz_u8, cz_u16, cz_u32, cz_u64   // Unsigned integers
cz_i8, cz_i16, cz_i32, cz_i64   // Signed integers
cz_f32, cz_f64                  // Floating-point types
cz_usize, cz_isize              // Architecture-dependent size types
```

These map to standard C types:
- `cz_u8` → `uint8_t`
- `cz_i32` → `int32_t`
- `cz_f32` → `float`
- `cz_usize` → `size_t`
- etc.

## Numeric Limit Constants

All integer types have associated min/max constants with `CZ_` prefix:

```c
CZ_U8_MIN, CZ_U8_MAX
CZ_U16_MIN, CZ_U16_MAX
CZ_U32_MIN, CZ_U32_MAX
CZ_U64_MIN, CZ_U64_MAX

CZ_I8_MIN, CZ_I8_MAX
CZ_I16_MIN, CZ_I16_MAX
CZ_I32_MIN, CZ_I32_MAX
CZ_I64_MIN, CZ_I64_MAX

CZ_USIZE_MIN, CZ_USIZE_MAX
CZ_ISIZE_MIN, CZ_ISIZE_MAX
```

Example usage:

```c
cz_u8 safe_add_u8(cz_u8 a, cz_u8 b) {
    cz_u32 result = (cz_u32)a + (cz_u32)b;
    if (result > CZ_U8_MAX) {
        return CZ_U8_MAX;  // Saturate at maximum
    }
    return (cz_u8)result;
}
```

## Runtime Macros

### Source Location Macros

```c
FILE    // Expands to __FILE__
LINE    // Expands to __LINE__
FUNC    // Expands to __func__
```

Example:

```c
void log_error(const char* msg) {
    fprintf(stderr, "[%s:%d in %s] %s\n", FILE, LINE, FUNC, msg);
}
```

## Assertion and Debugging Utilities

### `cz_assert(condition)`

Runtime assertion that aborts with diagnostic information if condition is false:

```c
cz_assert(ptr != NULL);
cz_assert(count > 0);
```

Output on failure:
```
file.c:42: function_name: Assertion failed: ptr != NULL
```

### `todo(message)`

Mark unimplemented code paths:

```c
void future_feature(void) {
    todo("implement this feature");
}
```

### `fixme(message)`

Mark code that needs attention:

```c
int buggy_function(void) {
    fixme("this has a race condition");
    // ... buggy code ...
}
```

### `cz_unreachable(message)`

Mark logically unreachable code:

```c
switch (value) {
    case 0: return "zero";
    case 1: return "one";
    default: cz_unreachable("unexpected value");
}
```

## Zero-Initialization

CZar mandates zero-initialization of local variables. While the current implementation relies on the programmer to initialize variables, future versions of the transpiler will automatically ensure all locals are zero-initialized.

```c
// In CZar, this is guaranteed to be zero-initialized
cz_u32 count;
cz_assert(count == 0);  // Will pass
```

## Usage

Include the header in your `.cz` files:

```c
#include "cz.h"

int main(void) {
    cz_u32 value = 42;
    cz_assert(value <= CZ_U32_MAX);
    printf("Value: %u\n", value);
    return 0;
}
```

## Examples

See test files for examples:
- `tests/v0.3_runtime.cz` - Comprehensive test of all features
- `tests/v0.3_demo.cz` - Practical usage examples
- `tests/v0.3_zero_init.cz` - Zero-initialization demonstration
