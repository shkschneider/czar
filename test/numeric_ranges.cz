#include <stdint.h>
#include <stddef.h>
#include <stdio.h>

/* Demonstrates practical usage of CZar type system */

/* Example: A simple vector structure using CZar types */
struct Vec2 {
    i32 x;
    i32 y;
};

/* Example: Computing with bounds checking using limit constants */
u8 safe_add_u8(u8 a, u8 b) {
    u32 result = cast<u32>(a) + cast<u32>(b);
    if (result > U8_MAX) {
        fprintf(stderr, "Overflow detected in safe_add_u8\n");
        return U8_MAX;
    }
    return cast<u8>(result);
}

/* Example: Range validation using limit constants */
int is_valid_i32(i64 value) {
    return value >= I32_MIN && value <= I32_MAX;
}

/* Example: Using runtime macros for debugging */
void debug_message(const char* msg) {
    fprintf(stderr, "[%s:%d in %s] %s\n", __FILE__, __LINE__, __func__, msg);
}

int main(void) {
    printf("=== CZar v0.3 Type System Demo ===\n\n");

    /* Test Vec2 structure */
    struct Vec2 v = {0};  /* Zero-initialized */
    v.x = 10;
    v.y = 20;
    printf("Vec2: (%d, %d)\n", v.x, v.y);

    /* Test safe addition */
    u8 a = 200;
    u8 b = 100;
    u8 sum = safe_add_u8(a = a, b = b);
    printf("safe_add_u8(%u, %u) = %u\n", a, b, sum);

    /* Test range validation */
    i64 big_value = 5000000000LL;
    printf("is_valid_i32(%lld) = %d\n", (long long)big_value, is_valid_i32(big_value));

    i64 small_value = 42;
    printf("is_valid_i32(%lld) = %d\n", (long long)small_value, is_valid_i32(small_value));

    /* Test runtime macros */
    debug_message("Testing runtime macros");

    /* Show numeric limits */
    printf("\nNumeric limits:\n");
    printf("  U8_MAX: %u\n", U8_MAX);
    printf("  I32_MIN: %d\n", I32_MIN);
    printf("  I32_MAX: %d\n", I32_MAX);

    /* Test ASSERTions */
    cz_assert(U8_MAX == 255);
    cz_assert(I32_MIN < 0);
    cz_assert(I32_MAX > 0);

    printf("\nDemo completed successfully!\n");
    return 0;
}
