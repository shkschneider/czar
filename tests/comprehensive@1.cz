// Comprehensive test combining all v1 features
struct Point {
    i32 x
    i32 y
}

struct Rect {
    Point top_left
    u32 width
    u32 height
}

// Method syntax on Point
fn Point:distance_squared() -> i32 {
    return self.x * self.x + self.y * self.y
}

// Extension method on Rect
fn Rect:area() -> u64 {
    u64 w = cast<u64> self.width
    u64 h = cast<u64> self.height
    return w * h
}

// Error-as-value for validation
struct ValidateResult {
    bool ok
    i32 error_msg
}

fn validate_point(Point p) -> ValidateResult {
    if p.x < 0 {
        return ValidateResult { ok: false, error_msg: 1 }
    }
    if p.y < 0 {
        return ValidateResult { ok: false, error_msg: 2 }
    }
    return ValidateResult { ok: true, error_msg: 0 }
}

fn main() -> i32 {
    Point p = Point { x: 3, y: 4 }

    // Test method call with auto-addressing
    i32 dist = p:distance_squared()

    // Test with different numeric types
    Rect r = Rect {
        top_left: Point { x: 0, y: 0 },
        width: cast<u32> 10,
        height: cast<u32> 5
    }

    // Test extension method
    u64 a = r:area()

    // Test error-as-value - pass by value
    ValidateResult result = validate_point(p)

    if result.ok {
        if dist == 25 {
            if a == 50 {
                return 1  // success
            }
        }
    }

    return 0
}
