// Test automatic cleanup with nested scopes

struct Node {
    i32 value
}

fn main() -> i32 {
    mut i32 result = 0
    
    // Outer scope allocation
    Node outer = new Node { value: 10 }
    result = result + outer.value
    
    // Nested scope with its own allocations
    if true {
        Node inner1 = new Node { value: 20 }
        Node inner2 = clone inner1
        result = result + inner1.value + inner2.value
        // inner1 and inner2 should be freed at end of this block
    }
    
    // Another nested scope
    if true {
        Node inner3 = new Node { value: 5 }
        result = result + inner3.value
        // inner3 should be freed at end of this block
    }
    
    // outer should be freed at end of function
    return result
}
// Expected: 10 + 20 + 20 + 5 = 55
