// Example from problem statement: `Person person = new Person { age: 25, score: 50 }`
// Demonstrates the new keyword for heap allocation with scope-based cleanup

struct Person {
    i32 age
    i32 score
}

fn update_age(mut Person p) -> void {
    p.age = p.age + 1
}

fn get_total(Person p) -> i32 {
    return p.age + p.score
}

fn main() -> i32 {
    // Example from problem statement: heap allocation without explicit pointer syntax
    mut Person person = new Person { age: 25, score: 50 }

    // Access fields normally (compiler handles pointer dereferencing)
    i32 initial_total = person.age + person.score  // 75

    // Pass as copy (without mut) - original not modified
    i32 total1 = get_total(person)  // 75

    // Modify directly
    person.age = 30

    // Pass with mut - original is modified
    update_age(mut person)  // age becomes 31

    // Verify final state
    i32 final_total = person.age + person.score  // 31 + 50 = 81

    // Return success if values are correct
    if initial_total == 75 {
        if total1 == 75 {
            if final_total == 81 {
                return 1  // Success
            }
        }
    }

    return 0  // Failure
}
