// Test demonstrating stack vs heap allocation with the new keyword
// Per requirement: "Node n = Node { value: 42 }" allocates on stack
//                  "Node n = new Node { value: 42 }" allocates on heap
// Both are copied when passed to functions unless mut is used

struct Node {
    mut i32 value
}

fn modify_by_copy(Node n) -> void {
    // This modifies the copy, not the original
    n.value = 999
}

fn modify_by_mut(mut Node n) -> void {
    // This modifies the original (passed by reference)
    n.value = 100
}

fn main() -> i32 {
    // Stack allocation
    mut Node stack_node = Node { value: 10 }
    
    // Heap allocation (compiler handles pointer internally)
    mut Node heap_node = new Node { value: 20 }
    
    // Test 1: Copy semantics (no mut)
    modify_by_copy(stack_node)
    modify_by_copy(heap_node)
    
    // Both should still have original values (10 and 20)
    mut i32 result = 0
    if stack_node.value == 10 {
        result = result + 1  // Pass
    }
    if heap_node.value == 20 {
        result = result + 1  // Pass
    }
    
    // Test 2: Reference semantics (with mut)
    modify_by_mut(mut stack_node)
    modify_by_mut(mut heap_node)
    
    // Both should be modified to 100
    if stack_node.value == 100 {
        result = result + 1  // Pass
    }
    if heap_node.value == 100 {
        result = result + 1  // Pass
    }
    
    // Should return 4 if all checks pass
    return result
}
