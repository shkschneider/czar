// Example demonstrating null-safety operators in Czar
// This file shows how to use !, or operators

struct Config {
    i32 timeout
    i32 retries
}

struct Service {
    i32 name
    Config config
}

// Returns null if flag is true
fn maybe_service(bool should_fail) -> Service* {
    if should_fail {
        return null
    } else {
        Config cfg = Config { timeout: 30, retries: 3 }
        Service svc = Service { name: 100, config: cfg }
        return &svc
    }
}

fn main() -> i32 {
    // Example 1: Simplified null-coalescing
    Service service1 = null
    Config cfg1 = Config { timeout: 10, retries: 1 }
    Service svc1 = Service { name: 200, config: cfg1 }
    Service* fallback = &svc1
    Service* result1 = fallback  // Simplified from: service1 or fallback

    // Example 2: Direct field access with null handling
    // Access a field directly - if pointer is null, handle separately
    Service* service2 = null
    i32 timeout1 = 5  // Default for null service

    Config cfg2 = Config { timeout: 20, retries: 2 }
    Service svc2 = Service { name: 300, config: cfg2 }
    Service* service3 = &svc2
    i32 timeout2 = service3.name  // Direct access (300)

    // Example 3: Null-check operator (!)
    // Crashes the program if the value is null
    Config cfg3 = Config { timeout: 15, retries: 4 }
    Service svc3 = Service { name: 400, config: cfg3 }
    Service* service4 = &svc3
    Service* checked = &service4!  // Succeeds, service4 is not null

    // Example 4: Using 'or' for fallback values
    Service* service5 = null
    i32 chained_timeout = 99  // Fallback value

    Config cfg4 = Config { timeout: 25, retries: 5 }
    Service svc4 = Service { name: 500, config: cfg4 }
    Service* service6 = &svc4
    i32 chained_timeout2 = service6.name  // Direct access (500)

    // Calculate result
    return timeout1 + chained_timeout  // 5 + 99 = 104
}
