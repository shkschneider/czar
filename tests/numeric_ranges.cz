#include <cz.h>
#include <stdio.h>

/* Demonstrates practical usage of CZar type system */

/* Example: A simple vector structure using CZar types */
struct Vec2 {
    cz_i32 x;
    cz_i32 y;
};

/* Example: Computing with bounds checking using limit constants */
cz_u8 safe_add_u8(cz_u8 a, cz_u8 b) {
    cz_u32 result = (cz_u32)a + (cz_u32)b;
    if (result > CZ_U8_MAX) {
        fprintf(stderr, "Overflow detected in safe_add_u8\n");
        return CZ_U8_MAX;
    }
    return (cz_u8)result;
}

/* Example: Range validation using limit constants */
int is_valid_i32(cz_i64 value) {
    return value >= CZ_I32_MIN && value <= CZ_I32_MAX;
}

/* Example: Using runtime macros for debugging */
void debug_message(const char* msg) {
    fprintf(stderr, "[%s:%d in %s] %s\n", FILE, LINE, FUNC, msg);
}

int main(void) {
    printf("=== CZar v0.3 Type System Demo ===\n\n");
    
    /* Test Vec2 structure */
    struct Vec2 v = {0};  /* Zero-initialized */
    v.x = 10;
    v.y = 20;
    printf("Vec2: (%d, %d)\n", v.x, v.y);
    
    /* Test safe addition */
    cz_u8 a = 200;
    cz_u8 b = 100;
    cz_u8 sum = safe_add_u8(a, b);
    printf("safe_add_u8(%u, %u) = %u\n", a, b, sum);
    
    /* Test range validation */
    cz_i64 big_value = 5000000000LL;
    printf("is_valid_i32(%lld) = %d\n", (long long)big_value, is_valid_i32(big_value));
    
    cz_i64 small_value = 42;
    printf("is_valid_i32(%lld) = %d\n", (long long)small_value, is_valid_i32(small_value));
    
    /* Test runtime macros */
    debug_message("Testing runtime macros");
    
    /* Show numeric limits */
    printf("\nNumeric limits:\n");
    printf("  CZ_U8_MAX: %u\n", CZ_U8_MAX);
    printf("  CZ_I32_MIN: %d\n", CZ_I32_MIN);
    printf("  CZ_I32_MAX: %d\n", CZ_I32_MAX);
    
    /* Test assertions */
    cz_assert(CZ_U8_MAX == 255);
    cz_assert(CZ_I32_MIN < 0);
    cz_assert(CZ_I32_MAX > 0);
    
    printf("\nDemo completed successfully!\n");
    return 0;
}
