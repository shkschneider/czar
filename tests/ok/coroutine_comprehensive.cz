// Test comprehensive coroutine functionality
#module ok
#import cz.co.*
#import cz.fmt.*

fn main() i32 {
    // Test 1: Basic coroutine with counter
    printf("Test 1: Basic counter coroutine\n")
    Coroutine? co1 = new Coroutine {}
    
    #unsafe {
        void counter() {
            for (uint8_t c = 1; c <= 5; c++) {
                _cz_co_yield((int32_t)c);
            }
        }
        co1->handle = _cz_co_init(counter);
    }
    
    // Resume multiple times
    mut i32 expected = 1
    while not co1:is_dead() {
        i32 val = co1:resume()
        if not co1:is_dead() {
            printf("Value: %d\n", val)
            if val != expected {
                printf("Error: expected %d, got %d\n", expected, val)
                return 1
            }
            expected = expected + 1
        }
    }
    
    // Test 2: Multiple coroutines interleaved
    printf("\nTest 2: Multiple coroutines\n")
    Coroutine? co2 = new Coroutine {}
    Coroutine? co3 = new Coroutine {}
    
    #unsafe {
        void counter_a() {
            for (uint8_t c = 10; c <= 13; c++) {
                _cz_co_yield((int32_t)c);
            }
        }
        void counter_b() {
            for (uint8_t c = 20; c <= 23; c++) {
                _cz_co_yield((int32_t)c);
            }
        }
        co2->handle = _cz_co_init(counter_a);
        co3->handle = _cz_co_init(counter_b);
    }
    
    // Alternate between coroutines
    mut i32 count = 0
    while count < 4 {
        i32 val_a = co2:resume()
        i32 val_b = co3:resume()
        printf("co2: %d, co3: %d\n", val_a, val_b)
        count = count + 1
    }
    
    // Test 3: Coroutine state queries
    printf("\nTest 3: State queries\n")
    Coroutine? co4 = new Coroutine {}
    
    #unsafe {
        void simple() {
            _cz_co_yield(100);
            _cz_co_yield(200);
        }
        co4->handle = _cz_co_init(simple);
    }
    
    if co4:is_ready() {
        printf("co4 is ready\n")
    }
    
    co4:resume()
    
    if co4:is_suspended() {
        printf("co4 is suspended after first yield\n")
    }
    
    co4:wait()  // Run until dead
    
    if co4:is_dead() {
        printf("co4 is dead after completion\n")
    }
    
    // Clean up
    free co1
    free co2
    free co3
    free co4
    
    printf("\nAll tests passed!\n")
    return 0
}
