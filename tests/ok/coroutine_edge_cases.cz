// Test coroutine edge cases and boundary conditions
#module ok
#import cz.co.*
#import cz.fmt.*

fn main() i32 {
    // Test 1: Empty coroutine (no yields)
    printf("Test 1: Empty coroutine\n")
    Coroutine? co1 = new Coroutine {}
    
    #unsafe {
        void empty() {
            // Does nothing, returns immediately
        }
        co1->handle = _cz_co_init(empty);
    }
    
    if co1:is_ready() {
        printf("Empty coroutine is ready\n")
    }
    
    co1:resume()
    
    if co1:is_dead() {
        printf("Empty coroutine finished immediately\n")
    }
    
    // Test 2: Single yield
    printf("\nTest 2: Single yield\n")
    Coroutine? co2 = new Coroutine {}
    
    #unsafe {
        void single_yield() {
            _cz_co_yield(42);
        }
        co2->handle = _cz_co_init(single_yield);
    }
    
    i32 val = co2:resume()
    printf("Yielded value: %d\n", val)
    
    if val != 42 {
        printf("Error: expected 42, got %d\n", val)
        return 1
    }
    
    co2:resume()  // Resume again, should be dead
    
    if not co2:is_dead() {
        printf("Error: coroutine should be dead\n")
        return 2
    }
    
    // Test 3: Large number of yields
    printf("\nTest 3: Many yields (100 values)\n")
    Coroutine? co3 = new Coroutine {}
    
    #unsafe {
        void many_yields() {
            for (int i = 0; i < 100; i++) {
                _cz_co_yield(i);
            }
        }
        co3->handle = _cz_co_init(many_yields);
    }
    
    mut i32 sum = 0
    mut i32 count = 0
    while not co3:is_dead() {
        i32 v = co3:resume()
        if not co3:is_dead() {
            sum = sum + v
            count = count + 1
        }
    }
    
    printf("Received %d values, sum: %d\n", count, sum)
    
    if count != 100 {
        printf("Error: expected 100 values, got %d\n", count)
        return 3
    }
    
    // Expected sum: 0+1+2+...+99 = 99*100/2 = 4950
    if sum != 4950 {
        printf("Error: expected sum 4950, got %d\n", sum)
        return 4
    }
    
    // Test 4: Zero value yields
    printf("\nTest 4: Zero and negative values\n")
    Coroutine? co4 = new Coroutine {}
    
    #unsafe {
        void zero_negative() {
            _cz_co_yield(0);
            _cz_co_yield(-1);
            _cz_co_yield(-100);
        }
        co4->handle = _cz_co_init(zero_negative);
    }
    
    i32 v1 = co4:resume()
    i32 v2 = co4:resume()
    i32 v3 = co4:resume()
    
    printf("Values: %d, %d, %d\n", v1, v2, v3)
    
    if v1 != 0 or v2 != -1 or v3 != -100 {
        printf("Error: unexpected values\n")
        return 5
    }
    
    // Test 5: Resume after dead
    printf("\nTest 5: Resume dead coroutine\n")
    Coroutine? co5 = new Coroutine {}
    
    #unsafe {
        void quick() {
            _cz_co_yield(1);
        }
        co5->handle = _cz_co_init(quick);
    }
    
    co5:resume()
    co5:resume()  // Should be dead now
    
    if not co5:is_dead() {
        printf("Error: coroutine should be dead\n")
        return 6
    }
    
    // Resume multiple times after dead - should be safe
    co5:resume()
    co5:resume()
    co5:resume()
    
    printf("Resumed dead coroutine safely\n")
    
    // Test 6: wait() on coroutine
    printf("\nTest 6: wait() functionality\n")
    Coroutine? co6 = new Coroutine {}
    
    #unsafe {
        void waitable() {
            for (int i = 0; i < 5; i++) {
                _cz_co_yield(i * 10);
            }
        }
        co6->handle = _cz_co_init(waitable);
    }
    
    co6:wait()  // Should consume all yields
    
    if not co6:is_dead() {
        printf("Error: wait() should run coroutine to completion\n")
        return 7
    }
    
    printf("wait() completed successfully\n")
    
    // Clean up
    free co1
    free co2
    free co3
    free co4
    free co5
    free co6
    
    printf("\nAll edge case tests passed!\n")
    return 0
}
