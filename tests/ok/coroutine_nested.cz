// Test nested and chained coroutine patterns
#module ok
#import cz.co.*
#import cz.fmt.*

fn main() i32 {
    printf("Testing nested and chained coroutine patterns\n\n")
    
    // Test 1: Chain of coroutines
    printf("Test 1: Chain of coroutines\n")
    Coroutine? co1 = new Coroutine {}
    Coroutine? co2 = new Coroutine {}
    Coroutine? co3 = new Coroutine {}
    
    #unsafe {
        void stage1() {
            for (int i = 0; i < 3; i++) {
                _cz_co_yield(i);
            }
        }
        void stage2() {
            for (int i = 10; i < 13; i++) {
                _cz_co_yield(i);
            }
        }
        void stage3() {
            for (int i = 20; i < 23; i++) {
                _cz_co_yield(i);
            }
        }
        co1->handle = _cz_co_init(stage1);
        co2->handle = _cz_co_init(stage2);
        co3->handle = _cz_co_init(stage3);
    }
    
    // Process stage 1
    printf("Processing stage 1: ")
    while not co1:is_dead() {
        i32 val = co1:resume()
        if not co1:is_dead() {
            printf("%d ", val)
        }
    }
    printf("\n")
    
    // Process stage 2
    printf("Processing stage 2: ")
    while not co2:is_dead() {
        i32 val = co2:resume()
        if not co2:is_dead() {
            printf("%d ", val)
        }
    }
    printf("\n")
    
    // Process stage 3
    printf("Processing stage 3: ")
    while not co3:is_dead() {
        i32 val = co3:resume()
        if not co3:is_dead() {
            printf("%d ", val)
        }
    }
    printf("\n")
    
    // Test 2: Round-robin scheduling
    printf("\nTest 2: Round-robin scheduling\n")
    Coroutine? rr1 = new Coroutine {}
    Coroutine? rr2 = new Coroutine {}
    Coroutine? rr3 = new Coroutine {}
    
    #unsafe {
        void task1() {
            for (int i = 0; i < 4; i++) {
                printf("    Task1: step %d\n", i);
                _cz_co_yield(i);
            }
        }
        void task2() {
            for (int i = 0; i < 4; i++) {
                printf("    Task2: step %d\n", i);
                _cz_co_yield(i + 10);
            }
        }
        void task3() {
            for (int i = 0; i < 4; i++) {
                printf("    Task3: step %d\n", i);
                _cz_co_yield(i + 20);
            }
        }
        rr1->handle = _cz_co_init(task1);
        rr2->handle = _cz_co_init(task2);
        rr3->handle = _cz_co_init(task3);
    }
    
    // Round-robin execution
    mut bool any_alive = true
    mut i32 round = 0
    while any_alive {
        printf("Round %d:\n", round)
        any_alive = false
        
        if not rr1:is_dead() {
            rr1:resume()
            any_alive = true
        }
        if not rr2:is_dead() {
            rr2:resume()
            any_alive = true
        }
        if not rr3:is_dead() {
            rr3:resume()
            any_alive = true
        }
        
        round = round + 1
    }
    
    printf("Completed %d rounds\n", round)
    
    // Note: Takes 4 rounds for yields, then 1 more to detect all dead, plus 1 final check
    if round < 5 or round > 6 {
        printf("Error: expected 5-6 rounds, got %d\n", round)
        return 1
    }
    
    // Test 3: Hierarchical execution
    printf("\nTest 3: Hierarchical execution\n")
    Coroutine? parent = new Coroutine {}
    Coroutine? child1 = new Coroutine {}
    Coroutine? child2 = new Coroutine {}
    
    #unsafe {
        void parent_task() {
            for (int i = 0; i < 2; i++) {
                printf("    Parent: iteration %d\n", i);
                _cz_co_yield(i * 100);
            }
        }
        void child_task1() {
            for (int i = 0; i < 3; i++) {
                printf("      Child1: item %d\n", i);
                _cz_co_yield(i);
            }
        }
        void child_task2() {
            for (int i = 0; i < 3; i++) {
                printf("      Child2: item %d\n", i);
                _cz_co_yield(i + 10);
            }
        }
        parent->handle = _cz_co_init(parent_task);
        child1->handle = _cz_co_init(child_task1);
        child2->handle = _cz_co_init(child_task2);
    }
    
    // Execute parent, then children for each parent step
    while not parent:is_dead() {
        i32 parent_val = parent:resume()
        if not parent:is_dead() {
            printf("  Parent yielded: %d\n", parent_val)
            
            // Execute child tasks
            if not child1:is_dead() {
                i32 child_val = child1:resume()
                if not child1:is_dead() {
                    printf("    Child1 yielded: %d\n", child_val)
                }
            }
            if not child2:is_dead() {
                i32 child_val = child2:resume()
                if not child2:is_dead() {
                    printf("    Child2 yielded: %d\n", child_val)
                }
            }
        }
    }
    
    // Complete any remaining child tasks
    printf("  Completing remaining child tasks\n")
    child1:wait()
    child2:wait()
    
    // Clean up
    free co1
    free co2
    free co3
    free rr1
    free rr2
    free rr3
    free parent
    free child1
    free child2
    
    printf("\nNested coroutine tests passed!\n")
    return 0
}
