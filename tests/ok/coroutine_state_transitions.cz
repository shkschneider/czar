// Test detailed state transitions in coroutines
#module ok
#import cz.co.*
#import cz.fmt.*

fn main() i32 {
    printf("Testing coroutine state transitions\n\n")
    
    // Test 1: READY -> RUNNING -> SUSPENDED -> RUNNING -> DEAD
    printf("Test 1: Complete state lifecycle\n")
    Coroutine? co = new Coroutine {}
    
    #unsafe {
        void stateful() {
            printf("  Coroutine: Started\n");
            _cz_co_yield(1);
            printf("  Coroutine: Resumed after first yield\n");
            _cz_co_yield(2);
            printf("  Coroutine: Resumed after second yield\n");
        }
        co->handle = _cz_co_init(stateful);
    }
    
    // Check READY state
    if not co:is_ready() {
        printf("Error: coroutine should be in READY state\n")
        return 1
    }
    printf("State: READY\n")
    
    // First resume - should yield and become SUSPENDED
    printf("Resuming...\n")
    i32 val1 = co:resume()
    printf("Yielded: %d\n", val1)
    
    if not co:is_suspended() {
        printf("Error: coroutine should be in SUSPENDED state\n")
        return 2
    }
    printf("State: SUSPENDED\n")
    
    // Second resume - should yield again and become SUSPENDED
    printf("Resuming again...\n")
    i32 val2 = co:resume()
    printf("Yielded: %d\n", val2)
    
    if not co:is_suspended() {
        printf("Error: coroutine should be in SUSPENDED state\n")
        return 3
    }
    printf("State: SUSPENDED\n")
    
    // Third resume - should complete and become DEAD
    printf("Final resume...\n")
    co:resume()
    
    if not co:is_dead() {
        printf("Error: coroutine should be in DEAD state\n")
        return 4
    }
    printf("State: DEAD\n")
    
    // Test 2: Check all state query methods
    printf("\nTest 2: State query methods\n")
    Coroutine? co2 = new Coroutine {}
    
    #unsafe {
        void simple() {
            _cz_co_yield(42);
        }
        co2->handle = _cz_co_init(simple);
    }
    
    // Initial state
    if co2:is_ready() {
        printf("is_ready: true (correct)\n")
    }
    if co2:is_running() {
        printf("Error: should not be running initially\n")
        return 5
    }
    if co2:is_suspended() {
        printf("Error: should not be suspended initially\n")
        return 6
    }
    if co2:is_dead() {
        printf("Error: should not be dead initially\n")
        return 7
    }
    
    // After first resume
    co2:resume()
    if not co2:is_suspended() {
        printf("Error: should be suspended after yield\n")
        return 8
    }
    if co2:is_ready() {
        printf("Error: should not be ready after first resume\n")
        return 9
    }
    printf("is_suspended: true (correct)\n")
    
    // After completion
    co2:resume()
    if not co2:is_dead() {
        printf("Error: should be dead after completion\n")
        return 10
    }
    if co2:is_suspended() {
        printf("Error: should not be suspended when dead\n")
        return 11
    }
    printf("is_dead: true (correct)\n")
    
    // Test 3: State transitions with multiple yields
    printf("\nTest 3: Multiple yields and state checks\n")
    Coroutine? co3 = new Coroutine {}
    
    #unsafe {
        void multi() {
            for (int i = 0; i < 3; i++) {
                _cz_co_yield(i);
            }
        }
        co3->handle = _cz_co_init(multi);
    }
    
    mut i32 cycle = 0
    while not co3:is_dead() {
        if cycle == 0 and not co3:is_ready() {
            printf("Error: should be ready before first resume\n")
            return 12
        }
        
        co3:resume()
        cycle = cycle + 1
        
        if cycle <= 3 {
            if not co3:is_suspended() and not co3:is_dead() {
                printf("Error: should be suspended or dead after resume %d\n", cycle)
                return 13
            }
        }
    }
    
    printf("Completed %d cycles\n", cycle)
    
    if cycle != 4 {
        printf("Error: expected 4 cycles (3 yields + 1 completion)\n")
        return 14
    }
    
    // Test 4: State after wait()
    printf("\nTest 4: State after wait()\n")
    Coroutine? co4 = new Coroutine {}
    
    #unsafe {
        void waiter() {
            for (int i = 0; i < 10; i++) {
                _cz_co_yield(i);
            }
        }
        co4->handle = _cz_co_init(waiter);
    }
    
    if not co4:is_ready() {
        printf("Error: should be ready before wait\n")
        return 15
    }
    
    co4:wait()
    
    if not co4:is_dead() {
        printf("Error: should be dead after wait\n")
        return 16
    }
    printf("After wait(): is_dead = true\n")
    
    // Clean up
    free co
    free co2
    free co3
    free co4
    
    printf("\nState transition tests passed!\n")
    return 0
}
