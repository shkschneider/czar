// Stress test for coroutines - performance and stability
#module ok
#import cz.co.*
#import cz.fmt.*

fn main() i32 {
    printf("Coroutine stress test\n\n")
    
    // Test 1: Many sequential yields
    printf("Test 1: 1000 sequential yields\n")
    Coroutine? co1 = new Coroutine {}
    
    #unsafe {
        void thousand_yields() {
            for (int i = 0; i < 1000; i++) {
                _cz_co_yield(i);
            }
        }
        co1->handle = _cz_co_init(thousand_yields);
    }
    
    mut i32 count1 = 0
    mut i32 last_val = -1
    while not co1:is_dead() {
        i32 val = co1:resume()
        if not co1:is_dead() {
            // Verify values are sequential
            if val != last_val + 1 {
                printf("Error: expected %d, got %d\n", last_val + 1, val)
                return 1
            }
            last_val = val
            count1 = count1 + 1
        }
    }
    
    printf("Successfully processed %d yields\n", count1)
    
    if count1 != 1000 {
        printf("Error: expected 1000 yields, got %d\n", count1)
        return 2
    }
    
    // Test 2: Multiple concurrent coroutines
    printf("\nTest 2: 10 concurrent coroutines\n")
    Coroutine? co2 = new Coroutine {}
    Coroutine? co3 = new Coroutine {}
    Coroutine? co4 = new Coroutine {}
    Coroutine? co5 = new Coroutine {}
    Coroutine? co6 = new Coroutine {}
    Coroutine? co7 = new Coroutine {}
    Coroutine? co8 = new Coroutine {}
    Coroutine? co9 = new Coroutine {}
    Coroutine? co10 = new Coroutine {}
    Coroutine? co11 = new Coroutine {}
    
    #unsafe {
        void task_a() { for (int i = 0; i < 10; i++) _cz_co_yield(i); }
        void task_b() { for (int i = 10; i < 20; i++) _cz_co_yield(i); }
        void task_c() { for (int i = 20; i < 30; i++) _cz_co_yield(i); }
        void task_d() { for (int i = 30; i < 40; i++) _cz_co_yield(i); }
        void task_e() { for (int i = 40; i < 50; i++) _cz_co_yield(i); }
        void task_f() { for (int i = 50; i < 60; i++) _cz_co_yield(i); }
        void task_g() { for (int i = 60; i < 70; i++) _cz_co_yield(i); }
        void task_h() { for (int i = 70; i < 80; i++) _cz_co_yield(i); }
        void task_i() { for (int i = 80; i < 90; i++) _cz_co_yield(i); }
        void task_j() { for (int i = 90; i < 100; i++) _cz_co_yield(i); }
        
        co2->handle = _cz_co_init(task_a);
        co3->handle = _cz_co_init(task_b);
        co4->handle = _cz_co_init(task_c);
        co5->handle = _cz_co_init(task_d);
        co6->handle = _cz_co_init(task_e);
        co7->handle = _cz_co_init(task_f);
        co8->handle = _cz_co_init(task_g);
        co9->handle = _cz_co_init(task_h);
        co10->handle = _cz_co_init(task_i);
        co11->handle = _cz_co_init(task_j);
    }
    
    mut i32 total_yields = 0
    
    // Each coroutine yields 10 times
    mut i32 iterations = 0
    while iterations < 10 {
        if not co2:is_dead() { co2:resume(); }
        if not co3:is_dead() { co3:resume(); }
        if not co4:is_dead() { co4:resume(); }
        if not co5:is_dead() { co5:resume(); }
        if not co6:is_dead() { co6:resume(); }
        if not co7:is_dead() { co7:resume(); }
        if not co8:is_dead() { co8:resume(); }
        if not co9:is_dead() { co9:resume(); }
        if not co10:is_dead() { co10:resume(); }
        if not co11:is_dead() { co11:resume(); }
        iterations = iterations + 1
    }
    
    total_yields = iterations * 10
    
    printf("Total yields from 10 coroutines: %d\n", total_yields)
    
    if total_yields != 100 {
        printf("Error: expected 100 total yields, got %d\n", total_yields)
        return 3
    }
    
    // Test 3: Alternating pattern stress
    printf("\nTest 3: Alternating pattern with 50 iterations\n")
    Coroutine? alt1 = new Coroutine {}
    Coroutine? alt2 = new Coroutine {}
    
    #unsafe {
        void alternator1() {
            for (int i = 0; i < 50; i++) {
                _cz_co_yield(i * 2);  // Even numbers
            }
        }
        void alternator2() {
            for (int i = 0; i < 50; i++) {
                _cz_co_yield(i * 2 + 1);  // Odd numbers
            }
        }
        alt1->handle = _cz_co_init(alternator1);
        alt2->handle = _cz_co_init(alternator2);
    }
    
    mut i32 even_count = 0
    mut i32 odd_count = 0
    
    while not alt1:is_dead() or not alt2:is_dead() {
        if not alt1:is_dead() {
            i32 even = alt1:resume()
            if not alt1:is_dead() {
                even_count = even_count + 1
            }
        }
        if not alt2:is_dead() {
            i32 odd = alt2:resume()
            if not alt2:is_dead() {
                odd_count = odd_count + 1
            }
        }
    }
    
    printf("Even numbers: %d, Odd numbers: %d\n", even_count, odd_count)
    
    if even_count != 50 or odd_count != 50 {
        printf("Error: expected 50 of each, got %d even and %d odd\n", even_count, odd_count)
        return 4
    }
    
    // Clean up
    free co1
    free co2
    free co3
    free co4
    free co5
    free co6
    free co7
    free co8
    free co9
    free co10
    free co11
    free alt1
    free alt2
    
    printf("\nStress test passed!\n")
    return 0
}
