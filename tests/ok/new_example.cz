// Example: explicit pointer syntax with heap allocation
// Demonstrates the new keyword for heap allocation with scope-based cleanup

struct Person {
    i32 age
    i32 score
}

fn update_age(mut Person* p) void {
    p.age = p.age + 1
}

fn get_total(Person* p) i32 {
    return p.age + p.score
}

fn main() i32 {
    // Heap allocation returns a pointer
    mut Person* person = new Person { age: 25, score: 50 }

    // Access fields through pointer (compiler handles -> vs .)
    i32 initial_total = person.age + person.score  // 75

    // <copy> Pass !! (dereference pointer) - original not modified
    i32 total1 = get_total(person)  // 75

    // Modify directly through pointer
    person.age = 30

    // Pass pointer - original is modified
    update_age(mut person)  // age becomes 31

    // Verify final state
    i32 final_total = person.age + person.score  // 31 + 50 = 81

    // Return success if values are correct
    if initial_total == 75 {
        if total1 == 75 {
            if final_total == 81 {
                return 0 // Success
            }
        }
    }

    return 81 // Failure
}
