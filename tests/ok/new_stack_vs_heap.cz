// Test demonstrating stack vs heap allocation with explicit pointer syntax
// "Node n = Node { value: 42 }" allocates on stack (value)
// "*Node n = new Node { value: 42 }" allocates on heap (pointer)

struct Node {
    i32 value
}

fn modify_by_copy(Node n) void {
    // This modifies the copy, not the original
    // ERROR n.value = 999 (n is immutable)
}

fn modify_by_ptr(mut *Node n) void {
    // This modifies through pointer
    n.value = 100
}

fn main() i32 {
    // Stack allocation (value)
    mut Node stack_node = Node { value: 10 }

    // Heap allocation (pointer)
    *Node heap_node = new Node { value: 20 }

    // Test 1: Copy semantics (pass by value)
    modify_by_copy(stack_node)
    modify_by_copy(*heap_node)  // dereference pointer to pass value

    // Both should still have original values (10 and 20)
    mut i32 result = 0
    if stack_node.value == 10 {
        result = result + 1  // Pass
    }
    if heap_node.value == 20 {
        result = result + 1  // Pass
    }

    // Test 2: Reference semantics (pass by pointer)
    modify_by_ptr(mut stack_node)  // take address of value
    modify_by_ptr(mut heap_node)    // already a pointer

    // Both should be modified to 100
    if stack_node.value == 100 {
        result = result + 1  // Pass
    }
    if heap_node.value == 100 {
        result = result + 1  // Pass
    }

    // Should return 4 if all checks pass
    return result - 4
}
