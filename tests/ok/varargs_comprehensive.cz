// Comprehensive varargs test demonstrating all features
// Varargs syntax: Type... name

// Function with only varargs
fn max(i32... values) i32 {
    if values[0] > values[1] {
        return values[0]
    } else {
        return values[1]
    }
}

// Function with fixed params and varargs
fn sum_with_base(i32 base, i32... values) i32 {
    mut i32 total = base
    mut i32 i = 0
    while i < 2 {
        total = total + values[i]
        i = i + 1
    }
    return total
}

// Varargs are read-only (like slices)
fn read_only_test(u8... data) u8 {
    // Can read from varargs
    return data[0]
}

fn main() i32 {
    // Test 1: Basic varargs
    i32 result1 = max(42, 10)

    // Test 2: Fixed params + varargs
    i32 result2 = sum_with_base(100, 20, 30)

    // Test 3: Different type (u8)
    u8 result3 = read_only_test(5, 10)

    // Test 4: Empty varargs (pass no varargs)
    // This would need a different function that accepts 0 args

    // Verify results
    mut i32 check = 0
    if result1 != 42 {
        check = check + 1
    }
    if result2 != 150 {
        check = check + 1
    }
    if cast<i32> result3 != 5 {
        check = check + 1
    }

    return check
}
